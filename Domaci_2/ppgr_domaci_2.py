# -*- coding: utf-8 -*-
"""ppgr_domaci_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10oTqH3E4yUVdjj_DJSw4JRwbsIzqKyhH
"""

import numpy as np
import math as math
import numpy.linalg as LA
import cv2
from google.colab.patches import cv2_imshow

# Funckija koja racuna teziste skupa tacaka u 2D
def izracunaj_teziste(tacke):
  n = len(tacke)
  C_x = 0
  C_y = 0

  for tacka in tacke:
    C_x += tacka[0]
    C_y += tacka[1]

  return (C_x/n, C_y/n)

def izracunaj_prosek_rastojanja(tacke):
  rastojanje = 0
  n = len(tacke)
  for tacka in tacke:
    rastojanje += math.sqrt(tacka[0]**2 + tacka[1]**2)

  return rastojanje/n    
'''
 Funckija koja vrsi normalizaciju tako sto prvo svaku tacku u skupu translira za vektor CO
 gde je C teziste skupa tacaka, a O koordinatni pocetak. Zatim se vrsi skaliranje kooridnata
 tako da prosecno rastojanje skupa tacaka do koordinatnog pocetka bude sqrt(2). Ovako dobijen
 skup tacaka se naziva normalizovan.
'''
def normalizuj(tacke):

  (C_x, C_y) = izracunaj_teziste(tacke)

  nova_lista = []
  for tacka in tacke:
    x = tacka[0] - C_x
    y = tacka[1] - C_y
    nova_lista.append([x, y])

  lam = izracunaj_prosek_rastojanja(nova_lista)
  tacke = []

  for tacka in nova_lista:
    x = (tacka[0]/lam)*math.sqrt(2)
    y = (tacka[1]/lam)*math.sqrt(2)
    tacke.append([x, y])

  matrica_translacije = np.array([[1, 0, -C_x], [0, 1, -C_y], [0, 0, 1]])
  matrica_homotetije = np.array([[math.sqrt(2)/lam, 0, 0], [0, math.sqrt(2)/lam, 0], [0, 0, 1]])
  matrica_transformacije = matrica_homotetije @ matrica_translacije

  return tacke, matrica_transformacije

tacke = [[1, 1], [5, 2], [6, 4], [-1, 7]]
tacke, matrica = normalizuj(tacke)
print(tacke)
print(matrica)

def prebaci_u_projektivne(tacke):
  lista = []
  for tacka in tacke:
    x = tacka[0]
    y = tacka[1]
    lista.append([x, y, 1])
  return lista

def prebaci_u_afine(tacke):
  lista = []
  for tacka in tacke:
    x = tacka[0]/tacka[2]
    y = tacka[1]/tacka[2]
    lista.append([x, y])
  return lista

# Funkcija koja formira matricu cije su kolone redom vektori A, B i C

def formiraj_matricu(A, B, C):
  array = np.array([A, B, C]).T
  return array

def izvuci_kolone(matrica):
  prva_kolona = []
  for i in range(3):
    prva_kolona.append(matrica[i][0])
  druga_kolona = []
  for i in range(3):
    druga_kolona.append(matrica[i][1])
  treca_kolona = []
  for i in range(3):
    treca_kolona.append(matrica[i][2])

  return prva_kolona, druga_kolona, treca_kolona

'''
  Ova funkcija predstavlja implementaciju naivnog algoritma za odredjivanje 
  matrice projektivnog preslikavanja za otklanjanje projektivne distorzije.
'''

def naivni(originali, slike):
  if (len(originali) != 4 or len(slike) != 4 or len(originali) != len(slike)):
    print("Funckija prima tacno 4 tacke!")
    return None

  originali = prebaci_u_projektivne(originali)
  slike = prebaci_u_projektivne(slike)
  
  A1, B1, C1, D1 = originali[0], originali[1], originali[2], originali[3]
  A2, B2, C2, D2 = slike[0], slike[1], slike[2], slike[3]
  D1 = np.array([D1]).T
  D2 = np.array([D2]).T

  matrica_1 = formiraj_matricu(A1, B1, C1)
  matrica_2 = formiraj_matricu(A2, B2, C2)
  
  # Potrbno je pronaci alfa, beta i gama iz izraza
  # D1 = alfa*A1 + beta*B1 + gama*C1
  # Slicno vazi i za kolone matrice matrica_2
  
  X = np.linalg.inv(matrica_1).dot(D1)
  Y = np.linalg.inv(matrica_2).dot(D2)

  prva_kolona, druga_kolona, treca_kolona = izvuci_kolone(matrica_1)
  P1 = formiraj_matricu(X[0]*prva_kolona, X[1]*druga_kolona, X[2]*treca_kolona)

  prva_kolona, druga_kolona, treca_kolona = izvuci_kolone(matrica_2)
  P2 = formiraj_matricu(Y[0]*prva_kolona, Y[1]*druga_kolona, Y[2]*treca_kolona)

  P = np.matmul(P2, LA.inv(P1))
  return P

print(naivni([[1, 1], [5, 2], [6, 4], [-1, 7]], [[0, 0], [10, 0], [10, 5], [0, 5]]))

'''
  Ova funkcija predstavlja implementaciju DLT algoritma za odredjivanje matrice
  projektivnog preslikavanja radi otklanjanja projektivne distorzije
'''

def DLT(originali, slike):
  if(len(originali) < 4 or len(slike) < 4 or len(originali) != len(slike)):
    print("Losi argumenti funkcije!")
    return None

  n = len(originali)

  originali = prebaci_u_projektivne(originali)
  slike = prebaci_u_projektivne(slike)

  matrica = np.array([]).reshape(0, 9)

  for i in range(0, n):
    tacka1 = originali[i]
    tacka2 = slike[i]

    pomocna = np.array([[0, 0, 0, -tacka2[2]*tacka1[0], -tacka2[2]*tacka1[1], -tacka2[2]*tacka1[2], tacka2[1]*tacka1[0], tacka2[1]*tacka1[1], tacka2[1]*tacka1[2]], 
                              [tacka2[2]*tacka1[0], tacka2[2]*tacka1[1], tacka2[2]*tacka1[2], 0, 0, 0, -tacka2[0]*tacka1[0], -tacka2[0]*tacka1[1], -tacka2[0]*tacka1[2]]])

    matrica = np.concatenate((matrica, pomocna), axis=0)

  _, _, v = np.linalg.svd(matrica, full_matrices=True)

  v = v[-1]
  return np.array([[v[0], v[1], v[2]], [v[3], v[4], v[5]], [v[6], v[7], v[8]]])

print("Matrica transformacije dobijena naivnim algoritmom:")
print(naivni([[1, 1], [5, 2], [6, 4], [-1, 7]], [[0, 0], [10, 0], [10, 5], [0, 5]]))
print('-------------------------------------------------------------')
print("Matrica transformacije dobijena DLT algoritmom:")
print(DLT([[1, 1], [5, 2], [6, 4], [-1, 7]], [[0, 0], [10, 0], [10, 5], [0, 5]]))

'''
  Ova funkcija predstavlja implementaciju unapredjenog DLT algoritma za odredjivanje 
  matrice projektivnog preslikavanja radi otklanjanja projektivne distorzije
'''

def DLT_unapredjeni(originali, slike):
  originali, matrica1 = normalizuj(originali)
  slike, matrica2 = normalizuj(slike)

  matrica = DLT(originali, slike)

  return np.linalg.inv(matrica2) @ matrica @ matrica1

print(DLT_unapredjeni([[1, 1], [5, 2], [6, 4], [-1, 7]], [[0, 0], [10, 0], [10, 5], [0, 5]]))
print()
print(DLT_unapredjeni([[3, 2], [4, -2], [6, -3], [9, 4]], [[5, -2], [15, 8], [10, 13], [0, 3]]))

'''
  U ovom delu koda uporedicemo rad DLT i unapredjenog DLT algoritma i pokazati
  da je unapredjeni DLT algoritam otporan na promenu koordinata
'''

'''
  U ovom delu koda uporedicemo rad DLT i unapredjenog DLT algoritma i pokazati
  da je unapredjeni DLT algoritam otporan na promenu koordinata
'''

# Funckija koja vrsi mnozenje matrice P i vektora a
def at(P, a):
    return np.matmul(P, np.array(a).T)

# Pocentne tacke
a = [-3, -1]
b = [3, -1]
c = [1, 1]
d = [-1, 1]
ap = [-2, -1]
bp = [2, -1]
cp = [2, 1]
dp = [-2, 1]

originali = [a, b, c, d]
print(f"Originalne tacke: {originali}")
slike = [ap, bp, cp, dp]
print(f"Slike tacaka: {slike}")

print("Matrica preslikavanja dobijena naivnim algoritmom:")
P1 = naivni(originali, slike)
print(P1)
print()
print("Matrica preslikavanja dobijena DLT algoritmom:")
P2 = DLT(originali, slike)
print(P2)
print()
P2skalirana = (P1[0][0]/P2[0][0])*P2
print("Skalirana matrica preslikavanja dobijena DLT algoritmom:")
print(P2skalirana)
print("=========================================================================================")
print()

e = [1/3, 2/3]
f = [-8, -2]
ep = [0.5, 0.25]
fp = [-4, -5/4]

originali = [a, b, c, d, e, f]
print(f"Originale tacke: {originali}")
slike = [ap, bp, cp, dp, ep, fp]
print(f"Slike tacaka: {slike}")

P3 = DLT(originali, slike)
print("Matrica preslikavanja dobijena DLT algoritmom za vise od 4 tacke")
print(P3)
print()
print("Skalirana matrica preslikavanja dobijena DLT algoritmom za vise od 4 tacke")
P3skalirana = (P1[0][0]/P3[0][0])*P3
print(P3skalirana)
print()
print("Odavde vidimo da se radi o istom preslikavanju.")
print("=========================================================================================")
print()
print("Matrica preslikavanja dobijena unapredjenim DLT algoritmom:")
P4 = DLT_unapredjeni(originali, slike)
print(P4)
print()
P4skalirana = (P1[0][0]/P4[0][0])*P4
print("Skalirana matrica preslikavanja dobijena unapredjenim DLT algoritmom:")
print(P4skalirana)
print()
print("Odavde vidimo da se vise ne radi o istom preslikavanju nego o pribliznom.")
print("=========================================================================================")
print()

print("Sada cemo da testiramo inverijantnost unapredjenog DLT algoritma na promenu koordinatnog sistema:")
CBM = np.array([[np.cos(1.5708), -np.sin(1.5708), 0],
                    [np.sin(1.5708), np.cos(1.5708), 0],
                    [0, 0, 1]])
print("Matrica transformacije kojom menjamo koordinate je:")
print(CBM)
print()
originaliProj = prebaci_u_projektivne(originali)
slikeProj = prebaci_u_projektivne(slike)

originali_nk = [at(CBM, x) for x in originaliProj]
slike_nk =    [at(CBM, x) for x in slikeProj]

P5 = DLT_unapredjeni(originali_nk, slike_nk)
print('Matrica preslikavanja u novom koordinatnom sistemu:')
print(P5)
print('Racunamo C^-1 * T * C')
P5skalirana = np.matmul(np.matmul(np.linalg.inv(CBM), P5), CBM)
print(f'P5s=\n{P5skalirana}\n')
print(f'Sada skaliramo: ')
P5sr = (P5[0][0]/P5skalirana[0][0]) * P5skalirana
print(P5sr)

def test():
  # Slucaj sa cetiri tacke
  orig = np.array([[-5,0,1], [-6,0.5,1], [-5,3,1], [-4,2,1]])
  nove = np.array([[3,0,1], [1,1.5,1], [2.7,2.5,1], [6,2,1]])

  print('Originalne tačke:')
  print(orig)
  print()

  print('Njihove slike:')
  print(nove)
  print()

  print('Matrica koju nam daje naivni algoritam:')
  naiv = naivni(nove, orig)
  print(naiv)
  print()

  print('Matrica koju nam daje DLT algoritam:')
  dlt = DLT(nove, orig)
  print(dlt)
  print()

  print('Skalirana DLT matrica:')
  print(naiv[0][0]/dlt[0][0] * dlt)
  print()

  print('Zaključak: u pitanju je ista transformacija.')
  print()

  print('Matrica koju nam daje unapredjeni DLT algoritam:')
  mdlt = DLT_unapredjeni(nove, orig)
  print(mdlt)
  print()

  print('Skalirana matrica unapredjenog DLT algoritma:')
  print(dlt[0][0]/mdlt[0][0] * mdlt)
  print()

  print('Zaključak: u pitanju je ista transformacija.')
  print()

  # Slucaj sa vise tacaka
  orig = np.array([[-5,0,1], [-6,0.5,1], [-5,3,1],
                   [-4,2,1], [-2,1.5,1], [-4,0,1]])
  nove = np.array([[3,0,1], [1,1.5,1], [2.7,2.5,1],
                   [6,2,1], [6.5,0.5,1], [4,0,1]])

  print('Originalne tačke:')
  print(orig)
  print()

  print('Njihove slike:')
  print(nove)
  print()

  print('Matrica koju nam vraca DLT algoritam bez šuma:')
  dlt0 = DLT(nove, orig)
  print(dlt0)
  print()

  print('Matrica koju nam vraca unapredjeni DLT algoritam bez šuma:')
  mdlt0 = DLT_unapredjeni(nove, orig)
  print(mdlt0)
  print()

  print('Skalirana matrica unapredjenog DLT algoritma:')
  print(dlt0[0][0]/mdlt0[0][0] * mdlt0)
  print()

  print('Zaključak: više tačaka unosi višeznačnost.')
  print('Sada se skaliranjem matirca unapredjenoh DLT algorima ne dobija ista matrica kao za DLT.')
  print()

  # Slucaj sa sumom
  orig[2], nove[0] = [-5.1,3,1], [3.1,0,1]

  print('Originali sa šumom:')
  print(orig)
  print()

  print('Slike sa šumom:')
  print(nove)
  print()

  print('DLT sa šumom:')
  dlt1 = DLT(nove, orig)
  print(dlt1)
  print()

  print('Skalirana matrica DLT algoritma:')
  print(dlt0[0][0]/dlt1[0][0] * dlt1)
  print()

  print('Matrica unapredjenog DLT algoritma sa šumom:')
  mdlt1 = DLT_unapredjeni(nove, orig)
  print(mdlt1)
  print()

  print('Skalirana matrica unapredjenog DLT algoritma:')
  print(mdlt0[0][0]/mdlt1[0][0] * mdlt1)
  print()

  print('Zaključak: šum donekle utiče na transformaciju.')

test()

def test_za_nove_tacke():
  n = int(input("Unesite broj tacaka koje zelite da unesete:"))
  originali = []
  slike = []

  print("Unesite koordinate za originale:")
  for i in range(n):
    x = float(input("Unesite x koordinatu: "))
    y = float(input("Unesite y koordinatu: "))
    originali.append([x, y])
  
  print()
  print("Unesite koordinate za slike:")
  for i in range(n):
    x = float(input("Unesite x koordinatu: "))
    y = float(input("Unesite y koordinatu: "))
    slike.append([x, y])

  print("Sada odaberite algoritam koji zelite da primenite na unete tacke:")
  print("1 - Naivni algoritam")
  print("2 - DLT algoritam")
  print("3 - Unapredjeni DLT algoritam")
  print("4 za kraj testiranja")

  while(True):
    alg = int(input("Unesite opciju:"))

    if alg == 1:
      print("Matrica preslikavanja dobijena naivnim algoritmom je:")
      print(naivni(originali, slike))
      print()
    elif alg == 2:
      print("Matrica preslikavanja dobijena DLT algoritmom je:")
      print(DLT(originali, slike))
      print()
    elif alg == 3:
      print("Matrica preslikavanja dobijena napredjenim DLT algoritmom je:")
      print(DLT_unapredjeni(originali, slike))
      print()
    elif alg == 4:
      break
    else:
      print("Uneli ste pogresan broj!")

test_za_nove_tacke()

def otklanjanje_projektivne_distorzije():
  
  img = cv2.imread(input("Unesite putanju do fotografije:"))
  img = cv2.resize(img, (800, 600))

  #src_pts = [[410, 262], [540, 269], [534, 357], [410, 340]]
  #dst_pts = [[150, 150], [300, 150], [300, 195], [150, 195]]

  src_pts = []
  dst_pts = []

  print("Unesite 4 para koordinata za originale:")
  for i in range(4):
    x = float(input("Unesite x koordinatu:"))
    y = float(input("Unesite y koordinatu"))
    src_pts.append([x, y])
  
  print()
  print("Unesite 4 para koordinata za slike:")
  for i in range(4):
    x = float(input("Unesite x koordinatu:"))
    y = float(input("Unesite y koordinatu"))
    dst_pts.append([x, y])

  matrix = DLT(src_pts, dst_pts)

  dst = cv2.warpPerspective(img, matrix, (img.shape[1], img.shape[0]))

  #dst = cv2.resize(dst, (800, 600))
  cv2_imshow(dst)

otklanjanje_projektivne_distorzije()

def trim(frame):
    #crop top
    if not np.sum(frame[0]):
        return trim(frame[1:])
    #crop top
    if not np.sum(frame[-1]):
        return trim(frame[:-2])
    #crop top
    if not np.sum(frame[:,0]):
        return trim(frame[:,1:])
    #crop top
    if not np.sum(frame[:,-1]):
        return trim(frame[:,:-2])
    return frame

def panorama():

    img_right = cv2.imread(input("Unesite putanju do desne fotografije: "))
    img_left = cv2.imread(input("Unesite putanju do leve fotografije: "))

    img1 = cv2.cvtColor(img_right, cv2.COLOR_BGR2GRAY)
    img2 = cv2.cvtColor(img_left, cv2.COLOR_BGR2GRAY)

    orb = cv2.ORB_create()

    kp1, des1 = orb.detectAndCompute(img1, None)
    kp2, des2 = orb.detectAndCompute(img2, None)

    bf = cv2.BFMatcher()

    matches = bf.knnMatch(des1, des2, k=2)

    good = []
    for m, n in matches:
        if m.distance < 1*n.distance:
            good.append(m)

    MIN_MATCH_COUNT = 10

    if(len(good) > MIN_MATCH_COUNT):
        src_points = np.float32([kp1[m.queryIdx].pt for m in good]).reshape(-1, 1, 2)
        dst_points = np.float32([kp2[m.trainIdx].pt for m in good]).reshape(-1, 1, 2)

        M, mask = cv2.findHomography(src_points, dst_points, cv2.RANSAC, 5.0)

        h, w = img1.shape
        pts = np.float32([[0, 0], [0, h-1], [w-1, h-1], [w-1, 0]]).reshape(-1, 1, 2)
        dst = cv2.perspectiveTransform(pts, M)
        img2 = cv2.polylines(img2, [np.int32(dst)], True, 255, 3, cv2.LINE_AA)
        #cv2.imshow("Overlap", img2)
        cv2.waitKey(10000)
    else:
        print("Not enough matches are found!")
        exit(1)

    dst = cv2.warpPerspective(img_right, M, (img_left.shape[1] + img_right.shape[1], img_left.shape[0]))
    dst[0:img_left.shape[0], 0:img_left.shape[1]] = img_left
    dst = cv2.resize(dst, (800, 600))
    cv2_imshow(trim(dst))

panorama()